# Example: Integrating Your Docker Compose Application with Cheetah

This example shows how to migrate the original Docker Compose application to run on Cheetah-managed Kubernetes infrastructure.

## Original Application Structure

```
your-app/
├── docker-compose.yml
├── backend/
│   ├── Dockerfile
│   └── main.py
├── frontend/
│   ├── Dockerfile
│   └── src/
└── database/
    └── init.sql
```

## Kubernetes Manifests

### 1. Namespace

```yaml
# namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: web-app
  labels:
    app: web-app
```

### 2. Database Secret

```yaml
# database-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: database-credentials
  namespace: web-app
type: Opaque
data:
  username: cG9zdGdyZXM=  # postgres (base64)
  password: cGFzc3dvcmQ=  # password (base64)
  database: bXlkYXRhYmFzZQ==  # mydatabase (base64)
```

### 3. Backend Deployment

```yaml
# backend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: web-app
  labels:
    app: backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: your-registry/backend:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          value: "postgresql://$(DB_USER):$(DB_PASSWORD)@$(DB_HOST):5432/$(DB_NAME)"
        - name: DB_HOST
          value: "database-service"
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: database-credentials
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: database-credentials
              key: password
        - name: DB_NAME
          valueFrom:
            secretKeyRef:
              name: database-credentials
              key: database
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: web-app
spec:
  selector:
    app: backend
  ports:
  - port: 8000
    targetPort: 8000
  type: ClusterIP
```

### 4. Frontend Deployment

```yaml
# frontend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: web-app
  labels:
    app: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: your-registry/frontend:latest
        ports:
        - containerPort: 80
        env:
        - name: REACT_APP_API_URL
          value: "/api"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "200m"
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: web-app
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
```

### 5. Database Configuration

```yaml
# database-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: database-init
  namespace: web-app
data:
  init.sql: |
    CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    INSERT INTO users (username, email) VALUES 
    ('john_doe', 'john@example.com'),
    ('jane_smith', 'jane@example.com')
    ON CONFLICT (username) DO NOTHING;
---
apiVersion: v1
kind: Service
metadata:
  name: database-service
  namespace: web-app
spec:
  type: ExternalName
  externalName: YOUR_RDS_ENDPOINT  # This will be replaced with actual RDS endpoint
```

### 6. Ingress (Load Balancer)

```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-app-ingress
  namespace: web-app
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"  # For HTTPS
spec:
  tls:
  - hosts:
    - your-domain.com
    secretName: web-app-tls
  rules:
  - host: your-domain.com
    http:
      paths:
      - path: /api(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: backend-service
            port:
              number: 8000
      - path: /()(.*)
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
```

## Deployment Steps

### 1. Build and Push Images

```bash
# Build backend image
cd backend
docker build -t your-registry/backend:latest .
docker push your-registry/backend:latest

# Build frontend image
cd ../frontend
docker build -t your-registry/frontend:latest .
docker push your-registry/frontend:latest
```

### 2. Deploy Cheetah Infrastructure

```bash
cd cheetah
./scripts/quickstart.sh
```

### 3. Get Database Endpoint

```bash
cd terraform
DATABASE_ENDPOINT=$(terraform output -raw database_endpoint)
echo "Database endpoint: $DATABASE_ENDPOINT"
```

### 4. Update Database Service

```bash
# Replace YOUR_RDS_ENDPOINT in database-service.yaml
sed -i "s/YOUR_RDS_ENDPOINT/$DATABASE_ENDPOINT/g" database-service.yaml
```

### 5. Deploy Application

```bash
# Create namespace
kubectl apply -f namespace.yaml

# Create secrets and config
kubectl apply -f database-secret.yaml
kubectl apply -f database-configmap.yaml

# Deploy services
kubectl apply -f database-service.yaml
kubectl apply -f backend-deployment.yaml
kubectl apply -f frontend-deployment.yaml

# Create ingress
kubectl apply -f ingress.yaml
```

### 6. Initialize Database

```bash
# Run database initialization
kubectl run -i --tty --rm database-init \
  --image=postgres:13 \
  --restart=Never \
  --namespace=web-app \
  -- psql -h $DATABASE_ENDPOINT -U postgres -d mydatabase -f /dev/stdin < database-init.sql
```

## Monitoring and Observability

### Health Checks

```bash
# Check pod status
kubectl get pods -n web-app

# Check service endpoints
kubectl get endpoints -n web-app

# Check ingress
kubectl get ingress -n web-app
```

### Logs

```bash
# Backend logs
kubectl logs -f deployment/backend -n web-app

# Frontend logs
kubectl logs -f deployment/frontend -n web-app
```

### Scaling

```bash
# Scale backend
kubectl scale deployment backend --replicas=5 -n web-app

# Scale frontend
kubectl scale deployment frontend --replicas=3 -n web-app
```

## CI/CD Integration

### GitHub Actions Workflow

```yaml
# .github/workflows/deploy.yml
name: Deploy to Kubernetes

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2
    
    - name: Login to ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    
    - name: Build and push backend
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: backend
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG backend/
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
    
    - name: Build and push frontend
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: frontend
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG frontend/
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
    
    - name: Deploy to EKS
      run: |
        aws eks update-kubeconfig --name your-cluster-name
        kubectl set image deployment/backend backend=$ECR_REGISTRY/backend:$IMAGE_TAG -n web-app
        kubectl set image deployment/frontend frontend=$ECR_REGISTRY/frontend:$IMAGE_TAG -n web-app
        kubectl rollout status deployment/backend -n web-app
        kubectl rollout status deployment/frontend -n web-app
```

## Production Considerations

1. **Security**: Use network policies, pod security policies
2. **Monitoring**: Deploy Prometheus, Grafana, and alerting
3. **Logging**: Centralized logging with ELK stack or Cloud providers
4. **Backup**: Database backup strategies
5. **Disaster Recovery**: Multi-region deployment
6. **Secrets Management**: Use external secret managers (AWS Secrets Manager, etc.)

This example demonstrates how to migrate from Docker Compose to a production-ready Kubernetes deployment using Cheetah infrastructure.
